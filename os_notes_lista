Linker:
Το πρώτο αφορά στο τι ακριβώς κάνει και πώς λειτουργεί ένας linker:
Ο Ian Lance Taylor έχει γράψει ένα εξαιρετικό αφιέρωμα σε 20 μέρη για το
πώς δουλεύει ένας linker, με αφορμή ότι ο ίδιος έγραψε έναν (ακόμη)
linker, τον gold: https://lwn.net/Articles/276782/

\==============================================================================\

Object files & relocation:
Για να δείτε ακριβώς πώς λειτουργεί η διαδικασία του relocation μπορείτε
να χρησιμοποιήσετε το εργαλείο objdump για να μελετήσετε ένα object file
όπως το παράγει ο gcc σε σύστημα Linux.

Με το objdump μπορείτε να δείτε, ανάμεσα στα άλλα, ποια sections ορίζει
το object (π.χ., ".text"), το disassembly του κώδικά των sections και τα
relocation tables που συνοδεύουν τα sections.

Ακολουθεί ένα σύντομο παράδειγμα χρήσης του εργαλείου κι επίδειξης των
relocations.

Εκτελέστε το, πειραματιστείτε, και στείλε για οποιαδήποτε απορία έχετε.

--

Ξεκινώντας από ένα απλό Hello World:

#include <stdio.h>

int main(void)
{
        printf("Hello, World!\n");

        return 0;
}

Το μεταγλωττίζουμε σε assembly x86-64:

$ gcc -S -o a.s a.c
$ cat a.s
        .file   "a.c"
        .section        .rodata
.LC0:
        .string "Hello, World!"
        .text
        .globl  main
        .type   main, @function
main:
.LFB0:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        movl    $.LC0, %edi
        call    puts
        movl    $0, %eax
        popq    %rbp
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE0:
        .size   main, .-main
        .ident  "GCC: (Debian 6.2.0-5) 6.2.0 20160927"
        .section        .note.GNU-stack,"",@progbits

[Παρατήρηση: gcc γνωρίζει την ειδική σημασία της συνάρτησης printf() και
την αλλάζει στην απλούστερη puts()! Δείτε και:

http://www.ciselant.de/projects/gcc_printf/gcc_printf.html ]

Ο assembler μεταφράζει την assembly στο εξής object:

$ as -o a.o a.s
$ file a.o
a.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped

Το object είναι ένα "relocatable" αρχείο ELF, που περιέχει κώδικα x86-64.

Χρησιμοποιούμε τον "gcc" ως frontend για τον linker και έχουμε το τελικό
εκτελέσιμο:

$ gcc -o a a.o
$ ./a
Hello, World!

Με objdump αναλύουμε το object. Το object περιέχει διάφορα sections:

$ objdump -s a.o
[...πολλά και διάφορα...]

Μας ενδιαφέρει το τι κώδικα περιέχει το section ".text":

$ objdump -d a.o

a.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:
   0:   55                      push   %rbp
   1:   48 89 e5                mov    %rsp,%rbp
   4:   bf 00 00 00 00          mov    $0x0,%edi
   9:   e8 00 00 00 00          callq  e <main+0xe>
   e:   b8 00 00 00 00          mov    $0x0,%eax
  13:   5d                      pop    %rbp
  14:   c3                      retq


To .text περιέχει μόνο μία συνάρτηση, τη main(), βλέπουμε τον κώδικά της.
Παρατηρούμε ότι η εντολή

    movl    $.LC0, %edi

της αρχικής assembly είναι στο offset 4, χωρίς να περιέχει τη διεύθυνση του
.LC0, αφού δεν ξέρει σε ποιο σημείο του εκτελέσιμου θα βρεθεί τελικά.
[Πού βρίσκεται το .LC0 μέσα στο object; στο section ".rodata"].

Η εντολή

    call    puts

της αρχικής assembly είναι στο offset 9, πάλι με μηδενικά αντί για
συγκεκριμένη διεύθυνση για το σύμβολο puts.
 
Και στις δύο περιπτώσεις, η διεύθυνση συμπληρώνεται με μηδενικά, αλλά το object
περιέχει ένα relocation table, που εξηγεί στον linker τι να συμπληρώσει πού:

$ objdump -r a.o

a.o:     file format elf64-x86-64

RELOCATION RECORDS FOR [.text]:
OFFSET           TYPE              VALUE
0000000000000005 R_X86_64_32       .rodata
000000000000000a R_X86_64_PC32     puts-0x0000000000000004


Δηλαδή: Για το section .text, στο offset 5 σημείωσε την απόλυτη διεύθυνση του
.rodata, αφού ξέρω ότι στην αρχή του είναι το .LC0 [δείτε objdump -s a.o], στο
offset 9 σημείωσε τη σχετική θέση της συνάρτησης puts σε σχέση με τη θέση του
PC (R_X86_64_PC32).

Δείτε και την απάντηση
https://stackoverflow.com/a/12412923
για τη σημασία του relocation "R_X86_64_PC32".

Πειραματιστείτε με το objdump [τρέξτε το και πάνω στο τελικό εκτελέσιμο!],
δείτε ποιες διευθύνσεις έχουν τελικά επιλυθεί, ποιες όχι [η puts()
βρίσκεται στη βιβλιοθήκη της C, άρα πώς ξέρει τελικά ο dynamic linker/loader
τι να συμπληρώσει; τι περιέχει το δυναμικό εκτελέσιμο; ]

\==============================================================================\

Linux memory map, malloc() vs sbrk():
Το Linux τηρεί χάρτη μνήμης (memory map) ανά διεργασία, που περιγράφει κάθε
περιοχή μέσα στο χώρο εικονικής μνήμης της συγκεκριμένης διεργασίας.

Για να δείτε το περιεχόμενο του χάρτη μνήμης, μπορείτε να διαβάσετε το
ειδικό αρχείο /proc/<pid>/maps, μέσω του οποίου ο πυρήνας εξάγει την
πληροφορία που περιέχει ο χάρτης μνήμης σε μορφή κειμένου.

Π.χ., για τη διεργασία του φλοιού που τρέχω, υπάρχουν οι εξής περιοχές:

$ cat /proc/$$/maps | less
00400000-004f3000 r-xp 00000000 09:00 2714673                            /bin/bash
006f2000-006f3000 r--p 000f2000 09:00 2714673                            /bin/bash
006f3000-006fc000 rw-p 000f3000 09:00 2714673                            /bin/bash
006fc000-00702000 rw-p 00000000 00:00 0
0243b000-027cc000 rw-p 00000000 00:00 0                                  [heap]
7f492dd31000-7f492dd3c000 r-xp 00000000 09:00 3273028                    /lib/x86_64-linux-gnu/libnss_files-2.23.so
7f492dd3c000-7f492df3b000 ---p 0000b000 09:00 3273028                    /lib/x86_64-linux-gnu/libnss_files-2.23.so
7f492df3b000-7f492df3c000 r--p 0000a000 09:00 3273028                    /lib/x86_64-linux-gnu/libnss_files-2.23.so
7f492df3c000-7f492df3d000 rw-p 0000b000 09:00 3273028                    /lib/x86_64-linux-gnu/libnss_files-2.23.so
7f492df3d000-7f492df43000 rw-p 00000000 00:00 0
[...]
7ffc59d48000-7ffc59d69000 rw-p 00000000 00:00 0                          [stack]
7ffc59d69000-7ffc59d6b000 r--p 00000000 00:00 0                          [vvar]
7ffc59d6b000-7ffc59d6d000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]

Για κάθε περιοχή μπορείτε να δείτε ποιο αρχείο έχει απεικονιστεί σε
αυτή, και με τι δικαιώματα. Π.χ., για το φλοιό μπορείτε να δείτε
ότι έχει απεικονιστεί το ίδιο το εκτελέσιμο, τόσο το text του (με
δικαίωμα 'x'), όσο και τα read-only και τα read-write δεδομένα του, μετά
είναι το heap, μετά απεικονίζονται στη σειρά βιβλιοθήκες και πάνω-πάνω
στην εικονική μνήμη είναι η στοίβα.

Σχετικά με το γιατί η malloc() δεν είναι system call και το πώς
λειτουργεί η κλήση συστήματος brk() δείτε αυτή την ωραία απάντηση από το
Stack Overflow: http://stackoverflow.com/a/6990428

\==============================================================================\

NULL pointer dereference:
Σε συνέχεια της συζήτησης γιατί η σελίδα 0 είναι σχεδόν πάντα unmapped,
καθώς η εικονική διεύθυνση 0 είναι η διεύθυνση του δείκτη NULL στον
x86, δείτε αυτό το ενδιαφέρον άρθρο:

https://blogs.oracle.com/ksplice/entry/much_ado_about_null_an1

Το άρθρο περιγράφει πώς μπορεί μια διεργασία ρητά να ζητήσει να
απεικονίσει πράγματα στην εικονική διεύθυνση 0, ουσιαστικά
παρακάμπτοντας την προστασία που ήδη υπάρχει ενάντια σε NULL-pointer
dereferences. Αυτό καταλήγει στο να κάνει

int *p = NULL;
*p = 5;

και να δουλεύουν όλα μια χαρά.

Δείτε επίσης την ειδική αναφορά στο πώς οι τελευταίες εκδόσεις του Linux
απαγορεύουν να απεικονίζονται πράγματα στη σελίδα 0 ακόμη κι αν η
διεργασία το ζητήσει ρητά. Γιατί;

\==============================================================================\

Virtual Memory:
Γράφω σε συνέχεια συζήτησης για τη μορφή που έχει ο χώρος εικονικών
διευθύνσεων κάθε διεργασίας στο Linux.

Δείτε αυτή την απάντηση από τον Robert Love, που συμμετέχει στην ανάπτυξη του πυρήνα:
		https://www.quora.com/Why-do-32-bit-Linux-kernels-only-recognize-3GB-of-RAM
στην οποία αναλύει ακριβώς με ποιον τρόπο και γιατί ο πυρήνας επιλέγει
να απεικονίσει τον εαυτό του στο πάνω 1GB του εικονικού χώρου κάθε
διεργασίας στον i386.

Για το πώς ο πυρήνας κάνει boot σε μια μηχανή x86 από τη στιγμή που θα
πατήσετε το κουμπί του power, πώς ξεκινά σε real mode και μετά περνά σε
protected mode, δείτε την εξής αναλυτική περιγραφή:
https://0xax.gitbooks.io/linux-insides/content/Booting/linux-bootstrap-1.html

Η οποία αποτελεί μέρος αυτού του βιβλίου που είναι υπό ανάπτυξη:
https://github.com/0xAX/linux-insides

\==============================================================================\

Filesystems:
Για να καταλάβετε καλύτερα τη διαδικασία επίλυσης ενός μονοπατιού από
την open() και συναφείς κλήσεις, καθώς και πώς μπλέκονται hard και soft
links σε αυτή, δείτε το manpage path_resolution(7):
http://man7.org/linux/man-pages/man7/path_resolution.7.html

Επίσης, προτείνω να ακολουθήσετε το σενάριο που ακολουθεί στο τέλος του
μηνύματος, για να δείτε από πρώτο χέρι πώς ένα σύστημα Linux χειρίζεται
hard και soft links. Ο μόνος τρόπος να καταλάβετε σε βάθος πώς
λειτουργεί το filesystem είναι να πειραματιστείτε.

Τέλος, αν ενδιαφέρεστε για την υλοποίηση ενός πραγματικού συστήματος
αρχείων, του ext2, δείτε:

* Design and Implementation of the Second Extended Filesystem:
  http://web.mit.edu/tytso/www/linux/ext2intro.html

* The Second Extended filesystem:
  http://wiki.osdev.org/Ext2
  
\==============================================================================\

Dynamic/Static Linking:
Αρχικά, όταν ένα πρόγραμμα συνδέεται στατικά με μία βιβλιοθήκη, αυτό θα
συμβεί κατά το χρόνο μεταγλώττισης-σύνδεσης (compile time) και το τελικό
εκτελέσιμο θα περιέχει και τα σύμβολα της βιβλιοθήκης, αυξάνοντας το
συνολικό του μέγεθος. Αντίθετα, όταν ένα πρόγραμμα συνδέεται δυναμικά με
μία βιβλιοθήκη, αυτό θα συμβεί κατά το χρόνο εκτέλεσης (run time).
Επίσης, κατά τη δυναμική σύνδεση, η βιβλιοθήκη υπάρχει ανεξαρτήτως του
εκτελέσιμου με αποτέλεσμα να μη χρειάζονται πολλαπλά αντίγραφα της
βιβλιοθήκης στη μνήμη, ακόμα και όταν διαφορετικά εκτελέσιμα συνδέονται
με αυτή.

Επιπλέον, σε συστήματα που υποστηρίζεται η CoW (Copy-on-Write) τεχνική
κατά το fork(), δε χρειάζεται να αντιγραφούν τα αντίστοιχα πλαίσια, παρά
μόνο όταν κάποια διεργασία στο μέλλον πραγματοποιήσει εγγραφή σε κάποιο
από αυτά, οπότε πλέον προκύπτουν διαφορετικά περιεχόμενα για τη
διεργασία-παιδί σε σχέση με αυτά της διεργασίας-πατέρα.

Στην περίπτωση της στατικής σύνδεσης κάποιας βιβλιοθήκης με το
πρόγραμμα, όπως αναφέραμε και σε προηγούμενο μήνυμα στη λίστα (02/02), η
βιβλιοθήκη αυτή ενσωματώνεται στο τελικό εκτελέσιμο αρχείο. Σε ένα
παράδειγμα που αυτό το αρχείο καταλαμβάνει αντίστοιχο χώρο 1 πλαισίου,
τότε αυτό το πλαίσιο θα φορτωθεί στην αρχή της εκτέλεσης του
προγράμματος, γιατί τότε χρειάζεται ο κώδικάς του, ο οποίος τυχαίνει να
βρίσκεται στην ίδια σελίδα με την εν λόγω βιβλιοθήκη.

Αν, αργότερα, η διεργασία επιχειρήσει να εκτελέσει συνάρτηση που ανήκει
σε αυτή τη βιβλιοθήκη, τότε θα χρειαστεί να έρθει και η αντίστοιχη
σελίδα στη μνήμη. Σε αυτό το παράδειγμα, όμως, που τυχαίνει αυτή η
σελίδα να έχει ήδη φορτωθεί στη μνήμη (καθώς σε αυτήν υπάρχει και ο
κώδικας), δε χρειάζεται να φορτωθεί κάποια άλλη σελίδα στη μνήμη. Εκτός,
βέβαια, αν στο ενδιάμεσο για οποιονδήποτε λόγο (π.χ. swap-out), αυτή η
σελίδα έχει φύγει από τη μνήμη, οπότε τώρα θα πρέπει να ξαναφορτωθεί.

Σε περίπτωση που το τελικό αρχείο μαζί με τη στατική βιβλιοθήκη
καταλαμβάνει περισσότερες σελίδες, τότε φορτώνονται κάθε φορά όσες
σελίδες χρειάζονται χωρίς να αλλάζει η αντίστοιχη λογική. Π.χ. κατά την
εκτέλεση μίας συνάρτησης ο αντίστοιχος ορισμός της μπορεί να βρίσκεται
σε πλαίσιο που δεν έχει φορτωθεί στη μνήμη. Έτσι, κατά τη δημιουργία της
διεργασίας φορτώνονται π.χ. οι 2 σελίδες που περιέχουν τη main() και η
συνάρτηση που καλείται αργότερα και υπάρχει π.χ. στο 5ο πλαίσιο
φορτώνεται τότε. Τα νούμερα αυτά είναι ενδεικτικά.

Δεν παίζει κάποιο ρόλο το ότι είναι δυναμικά συνδεδεμένη για το πότε θα
φορτωθεί. Η απάντηση εξακολουθεί να ισχύει. Θα φορτωθεί όταν χρειαστεί,
ανεξαρτήτως αν είναι στατικά ή δυναμικά συνδεδεμένη. Και στις δύο
περιπτώσεις και σε οποιαδήποτε άλλη, η εκάστοτε σελίδα μπορεί να είναι
ήδη φορτωμένη στη μνήμη τη στιγμή που θα χρειαστεί.

Για παράδειγμα, στην περίπτωση της στατικά συνδεδεμένης βιβλιοθήκης,
μπορεί η σελίδα να βρίσκεται ήδη στη μνήμη γιατί περιέχει και κώδικα που
έχει ζητηθεί προηγουμένως. Αντίστοιχα, στο παράδειγμα της δυναμικά
συνδεδεμένης βιβλιοθήκης, μπορεί η σχετική σελίδα να έχει φορτωθεί γιατί
κάποια άλλη διεργασία επιχείρησε να προσπελάσει την αντίστοιχη συνάρτηση
της ίδιας δυναμικής βιβλιοθήκης (π.χ. mathlib), την οποία μπορεί να
μοιράζονται πολλές διεργασίες.
